{"ast":null,"code":"import trackStorageService from './trackStorageService';\nclass UnifiedAudioController {\n  constructor() {\n    this.audioElement = null;\n    this.currentTrack = null;\n    this.isPlaying = false;\n    this.volume = 50;\n    this.currentTime = 0;\n    this.duration = 0;\n    this.eventCallbacks = {};\n    this.stopListeners = new Map();\n    this.fadeInterval = null;\n    this.settings = {\n      volume: 0.5,\n      fadeInDuration: 2,\n      fadeOutDuration: 2,\n      crossfadeDuration: 1,\n      duckingEnabled: false,\n      duckingThreshold: -20,\n      duckingAmount: 0.5,\n      normalizationEnabled: false,\n      loopEnabled: false,\n      loopCount: 1\n    };\n    this.currentLoopCount = 0;\n    this.initializeAudioElement();\n  }\n  initializeAudioElement() {\n    // Create hidden audio element\n    this.audioElement = document.createElement('audio');\n    this.audioElement.style.display = 'none';\n    this.audioElement.preload = 'metadata';\n\n    // Set up event listeners\n    this.audioElement.addEventListener('loadedmetadata', this.handleLoadedMetadata.bind(this));\n    this.audioElement.addEventListener('timeupdate', this.handleTimeUpdate.bind(this));\n    this.audioElement.addEventListener('ended', this.handleEnded.bind(this));\n    this.audioElement.addEventListener('error', this.handleError.bind(this));\n    this.audioElement.addEventListener('play', this.handlePlay.bind(this));\n    this.audioElement.addEventListener('pause', this.handlePause.bind(this));\n\n    // Add to DOM\n    document.body.appendChild(this.audioElement);\n\n    // Set initial volume\n    this.setVolume(this.volume);\n  }\n\n  // Public methods\n  async playTrack(track, crossfade = false) {\n    return new Promise((resolve, reject) => {\n      if (!this.audioElement) {\n        reject(new Error('Audio element not initialized'));\n        return;\n      }\n\n      // Determine audio source\n      const audioSrc = this.getAudioSource(track);\n      if (!audioSrc) {\n        reject(new Error('Track has no valid audio source'));\n        return;\n      }\n      try {\n        // Handle crossfade if enabled\n        if (crossfade && this.isPlaying && this.currentTrack) {\n          this.crossfadeToTrack(track, audioSrc, resolve, reject);\n        } else {\n          // Stop current track and play new one\n          if (this.isPlaying) {\n            this.stopCurrentTrack();\n          }\n          this.playNewTrack(track, audioSrc, resolve, reject);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  getAudioSource(track) {\n    // Priority: audioUrl (Suno), then fallback to tracks directory\n    if (track.audioUrl) {\n      return track.audioUrl;\n    }\n\n    // Fallback to tracks directory based on title\n    if (track.title) {\n      // Try to match with existing track files\n      const trackTitle = track.title.toLowerCase().replace(/\\s+/g, '');\n      return `/tracks/${trackTitle}.mp3`;\n    }\n    return null;\n  }\n  async playNewTrack(track, audioSrc, resolve, reject) {\n    try {\n      // Set new track\n      this.currentTrack = track;\n      this.audioElement.src = audioSrc;\n      this.audioElement.load();\n\n      // Reset loop counter\n      this.currentLoopCount = 0;\n\n      // Play the track\n      await this.audioElement.play();\n      this.isPlaying = true;\n      this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n      this.notifyEventCallbacks('onTrackChange', this.currentTrack);\n\n      // Start fade in if enabled\n      if (this.settings.fadeInDuration > 0) {\n        this.fadeIn(this.settings.fadeInDuration);\n      }\n\n      // Update usage tracking\n      this.updateUsageTracking(track);\n      resolve();\n    } catch (error) {\n      reject(error);\n    }\n  }\n  async crossfadeToTrack(track, audioSrc, resolve, reject) {\n    try {\n      // Create temporary audio element for crossfade\n      const tempAudio = document.createElement('audio');\n      tempAudio.src = audioSrc;\n      tempAudio.volume = 0;\n      tempAudio.preload = 'metadata';\n\n      // Wait for metadata to load\n      await new Promise(metadataResolve => {\n        tempAudio.addEventListener('loadedmetadata', () => metadataResolve());\n        tempAudio.load();\n      });\n\n      // Start fade out of current track\n      this.fadeOut(this.settings.crossfadeDuration);\n\n      // Start fade in of new track\n      tempAudio.volume = 0;\n      await tempAudio.play();\n\n      // Fade in new track\n      this.fadeInElement(tempAudio, this.settings.crossfadeDuration);\n\n      // After crossfade duration, switch to new track\n      setTimeout(() => {\n        // Update current track\n        this.currentTrack = track;\n        this.audioElement.src = audioSrc;\n        this.audioElement.load();\n        this.audioElement.volume = this.volume / 100;\n\n        // Remove temp audio\n        tempAudio.remove();\n\n        // Update usage tracking\n        this.updateUsageTracking(track);\n        resolve();\n      }, this.settings.crossfadeDuration * 1000);\n    } catch (error) {\n      reject(error);\n    }\n  }\n  pause() {\n    if (this.audioElement && this.isPlaying) {\n      this.audioElement.pause();\n      this.isPlaying = false;\n      this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n    }\n  }\n  resume() {\n    if (this.audioElement && !this.isPlaying && this.currentTrack) {\n      this.audioElement.play().then(() => {\n        this.isPlaying = true;\n        this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n      }).catch(error => {\n        this.notifyEventCallbacks('onError', `Failed to resume: ${error.message}`);\n      });\n    }\n  }\n  stop() {\n    this.stopCurrentTrack();\n  }\n  setVolume(volume) {\n    this.volume = Math.max(0, Math.min(100, volume));\n    this.settings.volume = this.volume / 100;\n    if (this.audioElement) {\n      this.audioElement.volume = this.settings.volume;\n    }\n    this.notifyEventCallbacks('onVolumeChange', this.volume);\n  }\n  getVolume() {\n    return this.volume;\n  }\n  seekTo(time) {\n    if (this.audioElement && this.currentTrack) {\n      this.audioElement.currentTime = Math.max(0, Math.min(time, this.duration));\n    }\n  }\n  getCurrentState() {\n    return {\n      currentTrack: this.currentTrack,\n      isPlaying: this.isPlaying,\n      volume: this.volume,\n      currentTime: this.currentTime,\n      duration: this.duration,\n      isLooping: this.settings.loopEnabled,\n      loopCount: this.currentLoopCount\n    };\n  }\n  getCurrentTrack() {\n    return this.currentTrack;\n  }\n  isTrackPlaying() {\n    return this.isPlaying;\n  }\n  getCurrentTime() {\n    return this.currentTime;\n  }\n  getDuration() {\n    return this.duration;\n  }\n\n  // Fade effects\n  fadeIn(duration) {\n    if (!this.audioElement) return;\n    this.notifyEventCallbacks('onFadeStart', 'in', duration);\n    const startVolume = 0;\n    const endVolume = this.settings.volume;\n    const steps = 60; // 60fps\n    const stepDuration = duration / steps;\n    const volumeStep = (endVolume - startVolume) / steps;\n    let currentStep = 0;\n    this.audioElement.volume = startVolume;\n    this.fadeInterval = window.setInterval(() => {\n      currentStep++;\n      this.audioElement.volume = startVolume + volumeStep * currentStep;\n      if (currentStep >= steps) {\n        this.audioElement.volume = endVolume;\n        if (this.fadeInterval) {\n          clearInterval(this.fadeInterval);\n          this.fadeInterval = null;\n        }\n        this.notifyEventCallbacks('onFadeComplete', 'in');\n      }\n    }, stepDuration * 1000);\n  }\n  fadeOut(duration) {\n    if (!this.audioElement) return;\n    this.notifyEventCallbacks('onFadeStart', 'out', duration);\n    const startVolume = this.audioElement.volume;\n    const endVolume = 0;\n    const steps = 60; // 60fps\n    const stepDuration = duration / steps;\n    const volumeStep = (startVolume - endVolume) / steps;\n    let currentStep = 0;\n    this.fadeInterval = window.setInterval(() => {\n      currentStep++;\n      this.audioElement.volume = startVolume - volumeStep * currentStep;\n      if (currentStep >= steps) {\n        this.audioElement.volume = endVolume;\n        if (this.fadeInterval) {\n          clearInterval(this.fadeInterval);\n          this.fadeInterval = null;\n        }\n        this.notifyEventCallbacks('onFadeComplete', 'out');\n      }\n    }, stepDuration * 1000);\n  }\n  fadeInElement(audioElement, duration) {\n    const startVolume = 0;\n    const endVolume = this.settings.volume;\n    const steps = 60;\n    const stepDuration = duration / steps;\n    const volumeStep = (endVolume - startVolume) / steps;\n    let currentStep = 0;\n    audioElement.volume = startVolume;\n    const interval = window.setInterval(() => {\n      currentStep++;\n      audioElement.volume = startVolume + volumeStep * currentStep;\n      if (currentStep >= steps) {\n        audioElement.volume = endVolume;\n        clearInterval(interval);\n      }\n    }, stepDuration * 1000);\n  }\n\n  // Loop functionality\n  setLooping(enabled, count = -1) {\n    this.settings.loopEnabled = enabled;\n    this.settings.loopCount = count;\n    if (this.audioElement) {\n      this.audioElement.loop = enabled && count === -1; // HTML5 audio only supports infinite loops\n    }\n  }\n  getLoopSettings() {\n    return {\n      enabled: this.settings.loopEnabled,\n      count: this.settings.loopCount\n    };\n  }\n\n  // Settings management\n  getSettings() {\n    return {\n      ...this.settings\n    };\n  }\n  updateSettings(newSettings) {\n    this.settings = {\n      ...this.settings,\n      ...newSettings\n    };\n\n    // Apply volume setting immediately\n    if (newSettings.volume !== undefined) {\n      this.setVolume(newSettings.volume * 100);\n    }\n\n    // Apply loop setting immediately\n    if (newSettings.loopEnabled !== undefined || newSettings.loopCount !== undefined) {\n      var _newSettings$loopEnab, _newSettings$loopCoun;\n      this.setLooping((_newSettings$loopEnab = newSettings.loopEnabled) !== null && _newSettings$loopEnab !== void 0 ? _newSettings$loopEnab : this.settings.loopEnabled, (_newSettings$loopCoun = newSettings.loopCount) !== null && _newSettings$loopCoun !== void 0 ? _newSettings$loopCoun : this.settings.loopCount);\n    }\n  }\n\n  // Event handling\n  on(event, callback) {\n    this.eventCallbacks[event] = callback;\n  }\n  off(event) {\n    delete this.eventCallbacks[event];\n  }\n\n  // Stop listener management (for compatibility with existing code)\n  registerStopListener(trackId, callback) {\n    this.stopListeners.set(trackId, callback);\n  }\n  unregisterStopListener(trackId) {\n    this.stopListeners.delete(trackId);\n  }\n\n  // Usage tracking\n  updateUsageTracking(track) {\n    try {\n      const updatedTrack = {\n        ...track,\n        usageTracking: {\n          ...(track.usageTracking || {\n            usageCount: 0\n          }),\n          usageCount: (track.usageTracking && track.usageTracking.usageCount ? track.usageTracking.usageCount : 0) + 1,\n          lastUsed: new Date()\n        }\n      };\n\n      // Save to storage\n      trackStorageService.saveTrack(updatedTrack);\n\n      // Update current track reference\n      this.currentTrack = updatedTrack;\n    } catch (error) {\n      console.error('Error updating usage tracking:', error);\n    }\n  }\n\n  // Private methods\n  stopCurrentTrack() {\n    if (this.audioElement) {\n      this.audioElement.pause();\n      this.audioElement.currentTime = 0;\n    }\n    this.isPlaying = false;\n    this.currentTime = 0;\n\n    // Clear any active fade\n    if (this.fadeInterval) {\n      clearInterval(this.fadeInterval);\n      this.fadeInterval = null;\n    }\n\n    // Notify all stop listeners\n    this.stopListeners.forEach(callback => callback());\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n  handleLoadedMetadata() {\n    if (this.audioElement) {\n      this.duration = this.audioElement.duration;\n    }\n  }\n  handleTimeUpdate() {\n    if (this.audioElement) {\n      this.currentTime = this.audioElement.currentTime;\n      this.notifyEventCallbacks('onTimeUpdate', this.currentTime);\n    }\n  }\n  handleEnded() {\n    if (this.currentTrack) {\n      this.notifyEventCallbacks('onTrackEnd', this.currentTrack);\n\n      // Handle looping\n      if (this.settings.loopEnabled) {\n        if (this.settings.loopCount === -1 || this.currentLoopCount < this.settings.loopCount) {\n          this.currentLoopCount++;\n          if (this.audioElement) {\n            this.audioElement.currentTime = 0;\n            this.audioElement.play().catch(console.error);\n          }\n          return;\n        }\n      }\n    }\n    this.isPlaying = false;\n    this.currentTime = 0;\n    this.currentLoopCount = 0;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n  handleError() {\n    var _this$audioElement, _this$audioElement$er;\n    const errorMessage = ((_this$audioElement = this.audioElement) === null || _this$audioElement === void 0 ? void 0 : (_this$audioElement$er = _this$audioElement.error) === null || _this$audioElement$er === void 0 ? void 0 : _this$audioElement$er.message) || 'Unknown audio error';\n    this.notifyEventCallbacks('onError', errorMessage);\n    this.isPlaying = false;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n  handlePlay() {\n    this.isPlaying = true;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n  handlePause() {\n    this.isPlaying = false;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n  notifyEventCallbacks(event, ...args) {\n    const callback = this.eventCallbacks[event];\n    if (callback) {\n      try {\n        callback(...args);\n      } catch (error) {\n        console.error(`Error in ${event} callback:`, error);\n      }\n    }\n  }\n\n  // Cleanup\n  destroy() {\n    if (this.fadeInterval) {\n      clearInterval(this.fadeInterval);\n      this.fadeInterval = null;\n    }\n    if (this.audioElement) {\n      this.audioElement.pause();\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n    this.stopListeners.clear();\n    this.eventCallbacks = {};\n  }\n}\n\n// Export singleton instance\nconst unifiedAudioController = new UnifiedAudioController();\nexport default unifiedAudioController;\nexport { UnifiedAudioController };","map":{"version":3,"names":["trackStorageService","UnifiedAudioController","constructor","audioElement","currentTrack","isPlaying","volume","currentTime","duration","eventCallbacks","stopListeners","Map","fadeInterval","settings","fadeInDuration","fadeOutDuration","crossfadeDuration","duckingEnabled","duckingThreshold","duckingAmount","normalizationEnabled","loopEnabled","loopCount","currentLoopCount","initializeAudioElement","document","createElement","style","display","preload","addEventListener","handleLoadedMetadata","bind","handleTimeUpdate","handleEnded","handleError","handlePlay","handlePause","body","appendChild","setVolume","playTrack","track","crossfade","Promise","resolve","reject","Error","audioSrc","getAudioSource","crossfadeToTrack","stopCurrentTrack","playNewTrack","error","audioUrl","title","trackTitle","toLowerCase","replace","src","load","play","notifyEventCallbacks","fadeIn","updateUsageTracking","tempAudio","metadataResolve","fadeOut","fadeInElement","setTimeout","remove","pause","resume","then","catch","message","stop","Math","max","min","getVolume","seekTo","time","getCurrentState","isLooping","getCurrentTrack","isTrackPlaying","getCurrentTime","getDuration","startVolume","endVolume","steps","stepDuration","volumeStep","currentStep","window","setInterval","clearInterval","interval","setLooping","enabled","count","loop","getLoopSettings","getSettings","updateSettings","newSettings","undefined","_newSettings$loopEnab","_newSettings$loopCoun","on","event","callback","off","registerStopListener","trackId","set","unregisterStopListener","delete","updatedTrack","usageTracking","usageCount","lastUsed","Date","saveTrack","console","forEach","_this$audioElement","_this$audioElement$er","errorMessage","args","destroy","clear","unifiedAudioController"],"sources":["/Users/allendunn/Documents/Stream/stream-soundboard/src/services/unifiedAudioController.ts"],"sourcesContent":["import { StreamingTrack } from '../types/track';\nimport trackStorageService from './trackStorageService';\n\nexport interface AudioSettings {\n  volume: number;\n  fadeInDuration: number; // in seconds\n  fadeOutDuration: number; // in seconds\n  crossfadeDuration: number; // in seconds\n  duckingEnabled: boolean;\n  duckingThreshold: number; // dB threshold for ducking\n  duckingAmount: number; // how much to reduce volume (0-1)\n  normalizationEnabled: boolean;\n  loopEnabled: boolean;\n  loopCount: number; // -1 for infinite\n}\n\nexport interface AudioState {\n  currentTrack: StreamingTrack | null;\n  isPlaying: boolean;\n  volume: number;\n  currentTime: number;\n  duration: number;\n  isLooping: boolean;\n  loopCount: number;\n}\n\nexport interface AudioEventCallbacks {\n  onTrackChange?: (track: StreamingTrack | null) => void;\n  onPlayStateChange?: (isPlaying: boolean) => void;\n  onVolumeChange?: (volume: number) => void;\n  onTimeUpdate?: (currentTime: number) => void;\n  onTrackEnd?: (track: StreamingTrack) => void;\n  onError?: (error: string) => void;\n  onFadeStart?: (type: 'in' | 'out', duration: number) => void;\n  onFadeComplete?: (type: 'in' | 'out') => void;\n}\n\nclass UnifiedAudioController {\n  private audioElement: HTMLAudioElement | null = null;\n  private currentTrack: StreamingTrack | null = null;\n  private isPlaying: boolean = false;\n  private volume: number = 50;\n  private currentTime: number = 0;\n  private duration: number = 0;\n  private eventCallbacks: AudioEventCallbacks = {};\n  private stopListeners: Map<string, () => void> = new Map();\n  private fadeInterval: number | null = null;\n  private settings: AudioSettings = {\n    volume: 0.5,\n    fadeInDuration: 2,\n    fadeOutDuration: 2,\n    crossfadeDuration: 1,\n    duckingEnabled: false,\n    duckingThreshold: -20,\n    duckingAmount: 0.5,\n    normalizationEnabled: false,\n    loopEnabled: false,\n    loopCount: 1\n  };\n  private currentLoopCount: number = 0;\n\n  constructor() {\n    this.initializeAudioElement();\n  }\n\n  private initializeAudioElement() {\n    // Create hidden audio element\n    this.audioElement = document.createElement('audio');\n    this.audioElement.style.display = 'none';\n    this.audioElement.preload = 'metadata';\n    \n    // Set up event listeners\n    this.audioElement.addEventListener('loadedmetadata', this.handleLoadedMetadata.bind(this));\n    this.audioElement.addEventListener('timeupdate', this.handleTimeUpdate.bind(this));\n    this.audioElement.addEventListener('ended', this.handleEnded.bind(this));\n    this.audioElement.addEventListener('error', this.handleError.bind(this));\n    this.audioElement.addEventListener('play', this.handlePlay.bind(this));\n    this.audioElement.addEventListener('pause', this.handlePause.bind(this));\n    \n    // Add to DOM\n    document.body.appendChild(this.audioElement);\n    \n    // Set initial volume\n    this.setVolume(this.volume);\n  }\n\n  // Public methods\n  public async playTrack(track: StreamingTrack, crossfade: boolean = false): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.audioElement) {\n        reject(new Error('Audio element not initialized'));\n        return;\n      }\n\n      // Determine audio source\n      const audioSrc = this.getAudioSource(track);\n      if (!audioSrc) {\n        reject(new Error('Track has no valid audio source'));\n        return;\n      }\n\n      try {\n        // Handle crossfade if enabled\n        if (crossfade && this.isPlaying && this.currentTrack) {\n          this.crossfadeToTrack(track, audioSrc, resolve, reject);\n        } else {\n          // Stop current track and play new one\n          if (this.isPlaying) {\n            this.stopCurrentTrack();\n          }\n          this.playNewTrack(track, audioSrc, resolve, reject);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  private getAudioSource(track: StreamingTrack): string | null {\n    // Priority: audioUrl (Suno), then fallback to tracks directory\n    if (track.audioUrl) {\n      return track.audioUrl;\n    }\n    \n    // Fallback to tracks directory based on title\n    if (track.title) {\n      // Try to match with existing track files\n      const trackTitle = track.title.toLowerCase().replace(/\\s+/g, '');\n      return `/tracks/${trackTitle}.mp3`;\n    }\n    \n    return null;\n  }\n\n  private async playNewTrack(track: StreamingTrack, audioSrc: string, resolve: Function, reject: Function) {\n    try {\n      // Set new track\n      this.currentTrack = track;\n      this.audioElement!.src = audioSrc;\n      this.audioElement!.load();\n\n      // Reset loop counter\n      this.currentLoopCount = 0;\n\n      // Play the track\n      await this.audioElement!.play();\n      \n      this.isPlaying = true;\n      this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n      this.notifyEventCallbacks('onTrackChange', this.currentTrack);\n      \n      // Start fade in if enabled\n      if (this.settings.fadeInDuration > 0) {\n        this.fadeIn(this.settings.fadeInDuration);\n      }\n\n      // Update usage tracking\n      this.updateUsageTracking(track);\n      \n      resolve();\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  private async crossfadeToTrack(track: StreamingTrack, audioSrc: string, resolve: Function, reject: Function) {\n    try {\n      // Create temporary audio element for crossfade\n      const tempAudio = document.createElement('audio');\n      tempAudio.src = audioSrc;\n      tempAudio.volume = 0;\n      tempAudio.preload = 'metadata';\n      \n      // Wait for metadata to load\n      await new Promise<void>((metadataResolve) => {\n        tempAudio.addEventListener('loadedmetadata', () => metadataResolve());\n        tempAudio.load();\n      });\n\n      // Start fade out of current track\n      this.fadeOut(this.settings.crossfadeDuration);\n      \n      // Start fade in of new track\n      tempAudio.volume = 0;\n      await tempAudio.play();\n      \n      // Fade in new track\n      this.fadeInElement(tempAudio, this.settings.crossfadeDuration);\n      \n      // After crossfade duration, switch to new track\n      setTimeout(() => {\n        // Update current track\n        this.currentTrack = track;\n        this.audioElement!.src = audioSrc;\n        this.audioElement!.load();\n        this.audioElement!.volume = this.volume / 100;\n        \n        // Remove temp audio\n        tempAudio.remove();\n        \n        // Update usage tracking\n        this.updateUsageTracking(track);\n        \n        resolve();\n      }, this.settings.crossfadeDuration * 1000);\n      \n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  public pause(): void {\n    if (this.audioElement && this.isPlaying) {\n      this.audioElement.pause();\n      this.isPlaying = false;\n      this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n    }\n  }\n\n  public resume(): void {\n    if (this.audioElement && !this.isPlaying && this.currentTrack) {\n      this.audioElement.play().then(() => {\n        this.isPlaying = true;\n        this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n      }).catch((error) => {\n        this.notifyEventCallbacks('onError', `Failed to resume: ${error.message}`);\n      });\n    }\n  }\n\n  public stop(): void {\n    this.stopCurrentTrack();\n  }\n\n  public setVolume(volume: number): void {\n    this.volume = Math.max(0, Math.min(100, volume));\n    this.settings.volume = this.volume / 100;\n    \n    if (this.audioElement) {\n      this.audioElement.volume = this.settings.volume;\n    }\n    \n    this.notifyEventCallbacks('onVolumeChange', this.volume);\n  }\n\n  public getVolume(): number {\n    return this.volume;\n  }\n\n  public seekTo(time: number): void {\n    if (this.audioElement && this.currentTrack) {\n      this.audioElement.currentTime = Math.max(0, Math.min(time, this.duration));\n    }\n  }\n\n  public getCurrentState(): AudioState {\n    return {\n      currentTrack: this.currentTrack,\n      isPlaying: this.isPlaying,\n      volume: this.volume,\n      currentTime: this.currentTime,\n      duration: this.duration,\n      isLooping: this.settings.loopEnabled,\n      loopCount: this.currentLoopCount\n    };\n  }\n\n  public getCurrentTrack(): StreamingTrack | null {\n    return this.currentTrack;\n  }\n\n  public isTrackPlaying(): boolean {\n    return this.isPlaying;\n  }\n\n  public getCurrentTime(): number {\n    return this.currentTime;\n  }\n\n  public getDuration(): number {\n    return this.duration;\n  }\n\n  // Fade effects\n  public fadeIn(duration: number): void {\n    if (!this.audioElement) return;\n    \n    this.notifyEventCallbacks('onFadeStart', 'in', duration);\n    \n    const startVolume = 0;\n    const endVolume = this.settings.volume;\n    const steps = 60; // 60fps\n    const stepDuration = duration / steps;\n    const volumeStep = (endVolume - startVolume) / steps;\n    \n    let currentStep = 0;\n    this.audioElement.volume = startVolume;\n    \n    this.fadeInterval = window.setInterval(() => {\n      currentStep++;\n      this.audioElement!.volume = startVolume + (volumeStep * currentStep);\n      \n      if (currentStep >= steps) {\n        this.audioElement!.volume = endVolume;\n        if (this.fadeInterval) {\n          clearInterval(this.fadeInterval);\n          this.fadeInterval = null;\n        }\n        this.notifyEventCallbacks('onFadeComplete', 'in');\n      }\n    }, stepDuration * 1000);\n  }\n\n  public fadeOut(duration: number): void {\n    if (!this.audioElement) return;\n    \n    this.notifyEventCallbacks('onFadeStart', 'out', duration);\n    \n    const startVolume = this.audioElement.volume;\n    const endVolume = 0;\n    const steps = 60; // 60fps\n    const stepDuration = duration / steps;\n    const volumeStep = (startVolume - endVolume) / steps;\n    \n    let currentStep = 0;\n    \n    this.fadeInterval = window.setInterval(() => {\n      currentStep++;\n      this.audioElement!.volume = startVolume - (volumeStep * currentStep);\n      \n      if (currentStep >= steps) {\n        this.audioElement!.volume = endVolume;\n        if (this.fadeInterval) {\n          clearInterval(this.fadeInterval);\n          this.fadeInterval = null;\n        }\n        this.notifyEventCallbacks('onFadeComplete', 'out');\n      }\n    }, stepDuration * 1000);\n  }\n\n  private fadeInElement(audioElement: HTMLAudioElement, duration: number): void {\n    const startVolume = 0;\n    const endVolume = this.settings.volume;\n    const steps = 60;\n    const stepDuration = duration / steps;\n    const volumeStep = (endVolume - startVolume) / steps;\n    \n    let currentStep = 0;\n    audioElement.volume = startVolume;\n    \n    const interval = window.setInterval(() => {\n      currentStep++;\n      audioElement.volume = startVolume + (volumeStep * currentStep);\n      \n      if (currentStep >= steps) {\n        audioElement.volume = endVolume;\n        clearInterval(interval);\n      }\n    }, stepDuration * 1000);\n  }\n\n  // Loop functionality\n  public setLooping(enabled: boolean, count: number = -1): void {\n    this.settings.loopEnabled = enabled;\n    this.settings.loopCount = count;\n    \n    if (this.audioElement) {\n      this.audioElement.loop = enabled && count === -1; // HTML5 audio only supports infinite loops\n    }\n  }\n\n  public getLoopSettings(): { enabled: boolean; count: number } {\n    return {\n      enabled: this.settings.loopEnabled,\n      count: this.settings.loopCount\n    };\n  }\n\n  // Settings management\n  public getSettings(): AudioSettings {\n    return { ...this.settings };\n  }\n\n  public updateSettings(newSettings: Partial<AudioSettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n    \n    // Apply volume setting immediately\n    if (newSettings.volume !== undefined) {\n      this.setVolume(newSettings.volume * 100);\n    }\n    \n    // Apply loop setting immediately\n    if (newSettings.loopEnabled !== undefined || newSettings.loopCount !== undefined) {\n      this.setLooping(\n        newSettings.loopEnabled ?? this.settings.loopEnabled,\n        newSettings.loopCount ?? this.settings.loopCount\n      );\n    }\n  }\n\n  // Event handling\n  public on(event: keyof AudioEventCallbacks, callback: any): void {\n    this.eventCallbacks[event] = callback;\n  }\n\n  public off(event: keyof AudioEventCallbacks): void {\n    delete this.eventCallbacks[event];\n  }\n\n  // Stop listener management (for compatibility with existing code)\n  public registerStopListener(trackId: string, callback: () => void): void {\n    this.stopListeners.set(trackId, callback);\n  }\n\n  public unregisterStopListener(trackId: string): void {\n    this.stopListeners.delete(trackId);\n  }\n\n  // Usage tracking\n  private updateUsageTracking(track: StreamingTrack): void {\n    try {\n      const updatedTrack = {\n        ...track,\n        usageTracking: {\n          ...(track.usageTracking || { usageCount: 0 }),\n          usageCount: ((track.usageTracking && track.usageTracking.usageCount) ? track.usageTracking.usageCount : 0) + 1,\n          lastUsed: new Date()\n        }\n      };\n      \n      // Save to storage\n      trackStorageService.saveTrack(updatedTrack);\n      \n      // Update current track reference\n      this.currentTrack = updatedTrack;\n    } catch (error) {\n      console.error('Error updating usage tracking:', error);\n    }\n  }\n\n  // Private methods\n  private stopCurrentTrack(): void {\n    if (this.audioElement) {\n      this.audioElement.pause();\n      this.audioElement.currentTime = 0;\n    }\n    \n    this.isPlaying = false;\n    this.currentTime = 0;\n    \n    // Clear any active fade\n    if (this.fadeInterval) {\n      clearInterval(this.fadeInterval);\n      this.fadeInterval = null;\n    }\n    \n    // Notify all stop listeners\n    this.stopListeners.forEach(callback => callback());\n    \n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n\n  private handleLoadedMetadata(): void {\n    if (this.audioElement) {\n      this.duration = this.audioElement.duration;\n    }\n  }\n\n  private handleTimeUpdate(): void {\n    if (this.audioElement) {\n      this.currentTime = this.audioElement.currentTime;\n      this.notifyEventCallbacks('onTimeUpdate', this.currentTime);\n    }\n  }\n\n  private handleEnded(): void {\n    if (this.currentTrack) {\n      this.notifyEventCallbacks('onTrackEnd', this.currentTrack);\n      \n      // Handle looping\n      if (this.settings.loopEnabled) {\n        if (this.settings.loopCount === -1 || this.currentLoopCount < this.settings.loopCount) {\n          this.currentLoopCount++;\n          if (this.audioElement) {\n            this.audioElement.currentTime = 0;\n            this.audioElement.play().catch(console.error);\n          }\n          return;\n        }\n      }\n    }\n    \n    this.isPlaying = false;\n    this.currentTime = 0;\n    this.currentLoopCount = 0;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n\n  private handleError(): void {\n    const errorMessage = this.audioElement?.error?.message || 'Unknown audio error';\n    this.notifyEventCallbacks('onError', errorMessage);\n    this.isPlaying = false;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n\n  private handlePlay(): void {\n    this.isPlaying = true;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n\n  private handlePause(): void {\n    this.isPlaying = false;\n    this.notifyEventCallbacks('onPlayStateChange', this.isPlaying);\n  }\n\n  private notifyEventCallbacks(event: keyof AudioEventCallbacks, ...args: any[]): void {\n    const callback = this.eventCallbacks[event];\n    if (callback) {\n      try {\n        (callback as Function)(...args);\n      } catch (error) {\n        console.error(`Error in ${event} callback:`, error);\n      }\n    }\n  }\n\n  // Cleanup\n  public destroy(): void {\n    if (this.fadeInterval) {\n      clearInterval(this.fadeInterval);\n      this.fadeInterval = null;\n    }\n    \n    if (this.audioElement) {\n      this.audioElement.pause();\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n    \n    this.stopListeners.clear();\n    this.eventCallbacks = {};\n  }\n}\n\n// Export singleton instance\nconst unifiedAudioController = new UnifiedAudioController();\nexport default unifiedAudioController;\nexport { UnifiedAudioController };\n"],"mappings":"AACA,OAAOA,mBAAmB,MAAM,uBAAuB;AAoCvD,MAAMC,sBAAsB,CAAC;EAwB3BC,WAAWA,CAAA,EAAG;IAAA,KAvBNC,YAAY,GAA4B,IAAI;IAAA,KAC5CC,YAAY,GAA0B,IAAI;IAAA,KAC1CC,SAAS,GAAY,KAAK;IAAA,KAC1BC,MAAM,GAAW,EAAE;IAAA,KACnBC,WAAW,GAAW,CAAC;IAAA,KACvBC,QAAQ,GAAW,CAAC;IAAA,KACpBC,cAAc,GAAwB,CAAC,CAAC;IAAA,KACxCC,aAAa,GAA4B,IAAIC,GAAG,CAAC,CAAC;IAAA,KAClDC,YAAY,GAAkB,IAAI;IAAA,KAClCC,QAAQ,GAAkB;MAChCP,MAAM,EAAE,GAAG;MACXQ,cAAc,EAAE,CAAC;MACjBC,eAAe,EAAE,CAAC;MAClBC,iBAAiB,EAAE,CAAC;MACpBC,cAAc,EAAE,KAAK;MACrBC,gBAAgB,EAAE,CAAC,EAAE;MACrBC,aAAa,EAAE,GAAG;MAClBC,oBAAoB,EAAE,KAAK;MAC3BC,WAAW,EAAE,KAAK;MAClBC,SAAS,EAAE;IACb,CAAC;IAAA,KACOC,gBAAgB,GAAW,CAAC;IAGlC,IAAI,CAACC,sBAAsB,CAAC,CAAC;EAC/B;EAEQA,sBAAsBA,CAAA,EAAG;IAC/B;IACA,IAAI,CAACrB,YAAY,GAAGsB,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;IACnD,IAAI,CAACvB,YAAY,CAACwB,KAAK,CAACC,OAAO,GAAG,MAAM;IACxC,IAAI,CAACzB,YAAY,CAAC0B,OAAO,GAAG,UAAU;;IAEtC;IACA,IAAI,CAAC1B,YAAY,CAAC2B,gBAAgB,CAAC,gBAAgB,EAAE,IAAI,CAACC,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1F,IAAI,CAAC7B,YAAY,CAAC2B,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAACG,gBAAgB,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;IAClF,IAAI,CAAC7B,YAAY,CAAC2B,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACI,WAAW,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;IACxE,IAAI,CAAC7B,YAAY,CAAC2B,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACK,WAAW,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;IACxE,IAAI,CAAC7B,YAAY,CAAC2B,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAACM,UAAU,CAACJ,IAAI,CAAC,IAAI,CAAC,CAAC;IACtE,IAAI,CAAC7B,YAAY,CAAC2B,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACO,WAAW,CAACL,IAAI,CAAC,IAAI,CAAC,CAAC;;IAExE;IACAP,QAAQ,CAACa,IAAI,CAACC,WAAW,CAAC,IAAI,CAACpC,YAAY,CAAC;;IAE5C;IACA,IAAI,CAACqC,SAAS,CAAC,IAAI,CAAClC,MAAM,CAAC;EAC7B;;EAEA;EACA,MAAamC,SAASA,CAACC,KAAqB,EAAEC,SAAkB,GAAG,KAAK,EAAiB;IACvF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC,IAAI,CAAC3C,YAAY,EAAE;QACtB2C,MAAM,CAAC,IAAIC,KAAK,CAAC,+BAA+B,CAAC,CAAC;QAClD;MACF;;MAEA;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,cAAc,CAACP,KAAK,CAAC;MAC3C,IAAI,CAACM,QAAQ,EAAE;QACbF,MAAM,CAAC,IAAIC,KAAK,CAAC,iCAAiC,CAAC,CAAC;QACpD;MACF;MAEA,IAAI;QACF;QACA,IAAIJ,SAAS,IAAI,IAAI,CAACtC,SAAS,IAAI,IAAI,CAACD,YAAY,EAAE;UACpD,IAAI,CAAC8C,gBAAgB,CAACR,KAAK,EAAEM,QAAQ,EAAEH,OAAO,EAAEC,MAAM,CAAC;QACzD,CAAC,MAAM;UACL;UACA,IAAI,IAAI,CAACzC,SAAS,EAAE;YAClB,IAAI,CAAC8C,gBAAgB,CAAC,CAAC;UACzB;UACA,IAAI,CAACC,YAAY,CAACV,KAAK,EAAEM,QAAQ,EAAEH,OAAO,EAAEC,MAAM,CAAC;QACrD;MACF,CAAC,CAAC,OAAOO,KAAK,EAAE;QACdP,MAAM,CAACO,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEQJ,cAAcA,CAACP,KAAqB,EAAiB;IAC3D;IACA,IAAIA,KAAK,CAACY,QAAQ,EAAE;MAClB,OAAOZ,KAAK,CAACY,QAAQ;IACvB;;IAEA;IACA,IAAIZ,KAAK,CAACa,KAAK,EAAE;MACf;MACA,MAAMC,UAAU,GAAGd,KAAK,CAACa,KAAK,CAACE,WAAW,CAAC,CAAC,CAACC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;MAChE,OAAO,WAAWF,UAAU,MAAM;IACpC;IAEA,OAAO,IAAI;EACb;EAEA,MAAcJ,YAAYA,CAACV,KAAqB,EAAEM,QAAgB,EAAEH,OAAiB,EAAEC,MAAgB,EAAE;IACvG,IAAI;MACF;MACA,IAAI,CAAC1C,YAAY,GAAGsC,KAAK;MACzB,IAAI,CAACvC,YAAY,CAAEwD,GAAG,GAAGX,QAAQ;MACjC,IAAI,CAAC7C,YAAY,CAAEyD,IAAI,CAAC,CAAC;;MAEzB;MACA,IAAI,CAACrC,gBAAgB,GAAG,CAAC;;MAEzB;MACA,MAAM,IAAI,CAACpB,YAAY,CAAE0D,IAAI,CAAC,CAAC;MAE/B,IAAI,CAACxD,SAAS,GAAG,IAAI;MACrB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;MAC9D,IAAI,CAACyD,oBAAoB,CAAC,eAAe,EAAE,IAAI,CAAC1D,YAAY,CAAC;;MAE7D;MACA,IAAI,IAAI,CAACS,QAAQ,CAACC,cAAc,GAAG,CAAC,EAAE;QACpC,IAAI,CAACiD,MAAM,CAAC,IAAI,CAAClD,QAAQ,CAACC,cAAc,CAAC;MAC3C;;MAEA;MACA,IAAI,CAACkD,mBAAmB,CAACtB,KAAK,CAAC;MAE/BG,OAAO,CAAC,CAAC;IACX,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdP,MAAM,CAACO,KAAK,CAAC;IACf;EACF;EAEA,MAAcH,gBAAgBA,CAACR,KAAqB,EAAEM,QAAgB,EAAEH,OAAiB,EAAEC,MAAgB,EAAE;IAC3G,IAAI;MACF;MACA,MAAMmB,SAAS,GAAGxC,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;MACjDuC,SAAS,CAACN,GAAG,GAAGX,QAAQ;MACxBiB,SAAS,CAAC3D,MAAM,GAAG,CAAC;MACpB2D,SAAS,CAACpC,OAAO,GAAG,UAAU;;MAE9B;MACA,MAAM,IAAIe,OAAO,CAAQsB,eAAe,IAAK;QAC3CD,SAAS,CAACnC,gBAAgB,CAAC,gBAAgB,EAAE,MAAMoC,eAAe,CAAC,CAAC,CAAC;QACrED,SAAS,CAACL,IAAI,CAAC,CAAC;MAClB,CAAC,CAAC;;MAEF;MACA,IAAI,CAACO,OAAO,CAAC,IAAI,CAACtD,QAAQ,CAACG,iBAAiB,CAAC;;MAE7C;MACAiD,SAAS,CAAC3D,MAAM,GAAG,CAAC;MACpB,MAAM2D,SAAS,CAACJ,IAAI,CAAC,CAAC;;MAEtB;MACA,IAAI,CAACO,aAAa,CAACH,SAAS,EAAE,IAAI,CAACpD,QAAQ,CAACG,iBAAiB,CAAC;;MAE9D;MACAqD,UAAU,CAAC,MAAM;QACf;QACA,IAAI,CAACjE,YAAY,GAAGsC,KAAK;QACzB,IAAI,CAACvC,YAAY,CAAEwD,GAAG,GAAGX,QAAQ;QACjC,IAAI,CAAC7C,YAAY,CAAEyD,IAAI,CAAC,CAAC;QACzB,IAAI,CAACzD,YAAY,CAAEG,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,GAAG;;QAE7C;QACA2D,SAAS,CAACK,MAAM,CAAC,CAAC;;QAElB;QACA,IAAI,CAACN,mBAAmB,CAACtB,KAAK,CAAC;QAE/BG,OAAO,CAAC,CAAC;MACX,CAAC,EAAE,IAAI,CAAChC,QAAQ,CAACG,iBAAiB,GAAG,IAAI,CAAC;IAE5C,CAAC,CAAC,OAAOqC,KAAK,EAAE;MACdP,MAAM,CAACO,KAAK,CAAC;IACf;EACF;EAEOkB,KAAKA,CAAA,EAAS;IACnB,IAAI,IAAI,CAACpE,YAAY,IAAI,IAAI,CAACE,SAAS,EAAE;MACvC,IAAI,CAACF,YAAY,CAACoE,KAAK,CAAC,CAAC;MACzB,IAAI,CAAClE,SAAS,GAAG,KAAK;MACtB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;IAChE;EACF;EAEOmE,MAAMA,CAAA,EAAS;IACpB,IAAI,IAAI,CAACrE,YAAY,IAAI,CAAC,IAAI,CAACE,SAAS,IAAI,IAAI,CAACD,YAAY,EAAE;MAC7D,IAAI,CAACD,YAAY,CAAC0D,IAAI,CAAC,CAAC,CAACY,IAAI,CAAC,MAAM;QAClC,IAAI,CAACpE,SAAS,GAAG,IAAI;QACrB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;MAChE,CAAC,CAAC,CAACqE,KAAK,CAAErB,KAAK,IAAK;QAClB,IAAI,CAACS,oBAAoB,CAAC,SAAS,EAAE,qBAAqBT,KAAK,CAACsB,OAAO,EAAE,CAAC;MAC5E,CAAC,CAAC;IACJ;EACF;EAEOC,IAAIA,CAAA,EAAS;IAClB,IAAI,CAACzB,gBAAgB,CAAC,CAAC;EACzB;EAEOX,SAASA,CAAClC,MAAc,EAAQ;IACrC,IAAI,CAACA,MAAM,GAAGuE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,GAAG,EAAEzE,MAAM,CAAC,CAAC;IAChD,IAAI,CAACO,QAAQ,CAACP,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,GAAG;IAExC,IAAI,IAAI,CAACH,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,CAACG,MAAM,GAAG,IAAI,CAACO,QAAQ,CAACP,MAAM;IACjD;IAEA,IAAI,CAACwD,oBAAoB,CAAC,gBAAgB,EAAE,IAAI,CAACxD,MAAM,CAAC;EAC1D;EAEO0E,SAASA,CAAA,EAAW;IACzB,OAAO,IAAI,CAAC1E,MAAM;EACpB;EAEO2E,MAAMA,CAACC,IAAY,EAAQ;IAChC,IAAI,IAAI,CAAC/E,YAAY,IAAI,IAAI,CAACC,YAAY,EAAE;MAC1C,IAAI,CAACD,YAAY,CAACI,WAAW,GAAGsE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACG,IAAI,EAAE,IAAI,CAAC1E,QAAQ,CAAC,CAAC;IAC5E;EACF;EAEO2E,eAAeA,CAAA,EAAe;IACnC,OAAO;MACL/E,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvB4E,SAAS,EAAE,IAAI,CAACvE,QAAQ,CAACQ,WAAW;MACpCC,SAAS,EAAE,IAAI,CAACC;IAClB,CAAC;EACH;EAEO8D,eAAeA,CAAA,EAA0B;IAC9C,OAAO,IAAI,CAACjF,YAAY;EAC1B;EAEOkF,cAAcA,CAAA,EAAY;IAC/B,OAAO,IAAI,CAACjF,SAAS;EACvB;EAEOkF,cAAcA,CAAA,EAAW;IAC9B,OAAO,IAAI,CAAChF,WAAW;EACzB;EAEOiF,WAAWA,CAAA,EAAW;IAC3B,OAAO,IAAI,CAAChF,QAAQ;EACtB;;EAEA;EACOuD,MAAMA,CAACvD,QAAgB,EAAQ;IACpC,IAAI,CAAC,IAAI,CAACL,YAAY,EAAE;IAExB,IAAI,CAAC2D,oBAAoB,CAAC,aAAa,EAAE,IAAI,EAAEtD,QAAQ,CAAC;IAExD,MAAMiF,WAAW,GAAG,CAAC;IACrB,MAAMC,SAAS,GAAG,IAAI,CAAC7E,QAAQ,CAACP,MAAM;IACtC,MAAMqF,KAAK,GAAG,EAAE,CAAC,CAAC;IAClB,MAAMC,YAAY,GAAGpF,QAAQ,GAAGmF,KAAK;IACrC,MAAME,UAAU,GAAG,CAACH,SAAS,GAAGD,WAAW,IAAIE,KAAK;IAEpD,IAAIG,WAAW,GAAG,CAAC;IACnB,IAAI,CAAC3F,YAAY,CAACG,MAAM,GAAGmF,WAAW;IAEtC,IAAI,CAAC7E,YAAY,GAAGmF,MAAM,CAACC,WAAW,CAAC,MAAM;MAC3CF,WAAW,EAAE;MACb,IAAI,CAAC3F,YAAY,CAAEG,MAAM,GAAGmF,WAAW,GAAII,UAAU,GAAGC,WAAY;MAEpE,IAAIA,WAAW,IAAIH,KAAK,EAAE;QACxB,IAAI,CAACxF,YAAY,CAAEG,MAAM,GAAGoF,SAAS;QACrC,IAAI,IAAI,CAAC9E,YAAY,EAAE;UACrBqF,aAAa,CAAC,IAAI,CAACrF,YAAY,CAAC;UAChC,IAAI,CAACA,YAAY,GAAG,IAAI;QAC1B;QACA,IAAI,CAACkD,oBAAoB,CAAC,gBAAgB,EAAE,IAAI,CAAC;MACnD;IACF,CAAC,EAAE8B,YAAY,GAAG,IAAI,CAAC;EACzB;EAEOzB,OAAOA,CAAC3D,QAAgB,EAAQ;IACrC,IAAI,CAAC,IAAI,CAACL,YAAY,EAAE;IAExB,IAAI,CAAC2D,oBAAoB,CAAC,aAAa,EAAE,KAAK,EAAEtD,QAAQ,CAAC;IAEzD,MAAMiF,WAAW,GAAG,IAAI,CAACtF,YAAY,CAACG,MAAM;IAC5C,MAAMoF,SAAS,GAAG,CAAC;IACnB,MAAMC,KAAK,GAAG,EAAE,CAAC,CAAC;IAClB,MAAMC,YAAY,GAAGpF,QAAQ,GAAGmF,KAAK;IACrC,MAAME,UAAU,GAAG,CAACJ,WAAW,GAAGC,SAAS,IAAIC,KAAK;IAEpD,IAAIG,WAAW,GAAG,CAAC;IAEnB,IAAI,CAAClF,YAAY,GAAGmF,MAAM,CAACC,WAAW,CAAC,MAAM;MAC3CF,WAAW,EAAE;MACb,IAAI,CAAC3F,YAAY,CAAEG,MAAM,GAAGmF,WAAW,GAAII,UAAU,GAAGC,WAAY;MAEpE,IAAIA,WAAW,IAAIH,KAAK,EAAE;QACxB,IAAI,CAACxF,YAAY,CAAEG,MAAM,GAAGoF,SAAS;QACrC,IAAI,IAAI,CAAC9E,YAAY,EAAE;UACrBqF,aAAa,CAAC,IAAI,CAACrF,YAAY,CAAC;UAChC,IAAI,CAACA,YAAY,GAAG,IAAI;QAC1B;QACA,IAAI,CAACkD,oBAAoB,CAAC,gBAAgB,EAAE,KAAK,CAAC;MACpD;IACF,CAAC,EAAE8B,YAAY,GAAG,IAAI,CAAC;EACzB;EAEQxB,aAAaA,CAACjE,YAA8B,EAAEK,QAAgB,EAAQ;IAC5E,MAAMiF,WAAW,GAAG,CAAC;IACrB,MAAMC,SAAS,GAAG,IAAI,CAAC7E,QAAQ,CAACP,MAAM;IACtC,MAAMqF,KAAK,GAAG,EAAE;IAChB,MAAMC,YAAY,GAAGpF,QAAQ,GAAGmF,KAAK;IACrC,MAAME,UAAU,GAAG,CAACH,SAAS,GAAGD,WAAW,IAAIE,KAAK;IAEpD,IAAIG,WAAW,GAAG,CAAC;IACnB3F,YAAY,CAACG,MAAM,GAAGmF,WAAW;IAEjC,MAAMS,QAAQ,GAAGH,MAAM,CAACC,WAAW,CAAC,MAAM;MACxCF,WAAW,EAAE;MACb3F,YAAY,CAACG,MAAM,GAAGmF,WAAW,GAAII,UAAU,GAAGC,WAAY;MAE9D,IAAIA,WAAW,IAAIH,KAAK,EAAE;QACxBxF,YAAY,CAACG,MAAM,GAAGoF,SAAS;QAC/BO,aAAa,CAACC,QAAQ,CAAC;MACzB;IACF,CAAC,EAAEN,YAAY,GAAG,IAAI,CAAC;EACzB;;EAEA;EACOO,UAAUA,CAACC,OAAgB,EAAEC,KAAa,GAAG,CAAC,CAAC,EAAQ;IAC5D,IAAI,CAACxF,QAAQ,CAACQ,WAAW,GAAG+E,OAAO;IACnC,IAAI,CAACvF,QAAQ,CAACS,SAAS,GAAG+E,KAAK;IAE/B,IAAI,IAAI,CAAClG,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,CAACmG,IAAI,GAAGF,OAAO,IAAIC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;IACpD;EACF;EAEOE,eAAeA,CAAA,EAAwC;IAC5D,OAAO;MACLH,OAAO,EAAE,IAAI,CAACvF,QAAQ,CAACQ,WAAW;MAClCgF,KAAK,EAAE,IAAI,CAACxF,QAAQ,CAACS;IACvB,CAAC;EACH;;EAEA;EACOkF,WAAWA,CAAA,EAAkB;IAClC,OAAO;MAAE,GAAG,IAAI,CAAC3F;IAAS,CAAC;EAC7B;EAEO4F,cAAcA,CAACC,WAAmC,EAAQ;IAC/D,IAAI,CAAC7F,QAAQ,GAAG;MAAE,GAAG,IAAI,CAACA,QAAQ;MAAE,GAAG6F;IAAY,CAAC;;IAEpD;IACA,IAAIA,WAAW,CAACpG,MAAM,KAAKqG,SAAS,EAAE;MACpC,IAAI,CAACnE,SAAS,CAACkE,WAAW,CAACpG,MAAM,GAAG,GAAG,CAAC;IAC1C;;IAEA;IACA,IAAIoG,WAAW,CAACrF,WAAW,KAAKsF,SAAS,IAAID,WAAW,CAACpF,SAAS,KAAKqF,SAAS,EAAE;MAAA,IAAAC,qBAAA,EAAAC,qBAAA;MAChF,IAAI,CAACV,UAAU,EAAAS,qBAAA,GACbF,WAAW,CAACrF,WAAW,cAAAuF,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAAC/F,QAAQ,CAACQ,WAAW,GAAAwF,qBAAA,GACpDH,WAAW,CAACpF,SAAS,cAAAuF,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAAChG,QAAQ,CAACS,SACzC,CAAC;IACH;EACF;;EAEA;EACOwF,EAAEA,CAACC,KAAgC,EAAEC,QAAa,EAAQ;IAC/D,IAAI,CAACvG,cAAc,CAACsG,KAAK,CAAC,GAAGC,QAAQ;EACvC;EAEOC,GAAGA,CAACF,KAAgC,EAAQ;IACjD,OAAO,IAAI,CAACtG,cAAc,CAACsG,KAAK,CAAC;EACnC;;EAEA;EACOG,oBAAoBA,CAACC,OAAe,EAAEH,QAAoB,EAAQ;IACvE,IAAI,CAACtG,aAAa,CAAC0G,GAAG,CAACD,OAAO,EAAEH,QAAQ,CAAC;EAC3C;EAEOK,sBAAsBA,CAACF,OAAe,EAAQ;IACnD,IAAI,CAACzG,aAAa,CAAC4G,MAAM,CAACH,OAAO,CAAC;EACpC;;EAEA;EACQnD,mBAAmBA,CAACtB,KAAqB,EAAQ;IACvD,IAAI;MACF,MAAM6E,YAAY,GAAG;QACnB,GAAG7E,KAAK;QACR8E,aAAa,EAAE;UACb,IAAI9E,KAAK,CAAC8E,aAAa,IAAI;YAAEC,UAAU,EAAE;UAAE,CAAC,CAAC;UAC7CA,UAAU,EAAE,CAAE/E,KAAK,CAAC8E,aAAa,IAAI9E,KAAK,CAAC8E,aAAa,CAACC,UAAU,GAAI/E,KAAK,CAAC8E,aAAa,CAACC,UAAU,GAAG,CAAC,IAAI,CAAC;UAC9GC,QAAQ,EAAE,IAAIC,IAAI,CAAC;QACrB;MACF,CAAC;;MAED;MACA3H,mBAAmB,CAAC4H,SAAS,CAACL,YAAY,CAAC;;MAE3C;MACA,IAAI,CAACnH,YAAY,GAAGmH,YAAY;IAClC,CAAC,CAAC,OAAOlE,KAAK,EAAE;MACdwE,OAAO,CAACxE,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACxD;EACF;;EAEA;EACQF,gBAAgBA,CAAA,EAAS;IAC/B,IAAI,IAAI,CAAChD,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,CAACoE,KAAK,CAAC,CAAC;MACzB,IAAI,CAACpE,YAAY,CAACI,WAAW,GAAG,CAAC;IACnC;IAEA,IAAI,CAACF,SAAS,GAAG,KAAK;IACtB,IAAI,CAACE,WAAW,GAAG,CAAC;;IAEpB;IACA,IAAI,IAAI,CAACK,YAAY,EAAE;MACrBqF,aAAa,CAAC,IAAI,CAACrF,YAAY,CAAC;MAChC,IAAI,CAACA,YAAY,GAAG,IAAI;IAC1B;;IAEA;IACA,IAAI,CAACF,aAAa,CAACoH,OAAO,CAACd,QAAQ,IAAIA,QAAQ,CAAC,CAAC,CAAC;IAElD,IAAI,CAAClD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;EAChE;EAEQ0B,oBAAoBA,CAAA,EAAS;IACnC,IAAI,IAAI,CAAC5B,YAAY,EAAE;MACrB,IAAI,CAACK,QAAQ,GAAG,IAAI,CAACL,YAAY,CAACK,QAAQ;IAC5C;EACF;EAEQyB,gBAAgBA,CAAA,EAAS;IAC/B,IAAI,IAAI,CAAC9B,YAAY,EAAE;MACrB,IAAI,CAACI,WAAW,GAAG,IAAI,CAACJ,YAAY,CAACI,WAAW;MAChD,IAAI,CAACuD,oBAAoB,CAAC,cAAc,EAAE,IAAI,CAACvD,WAAW,CAAC;IAC7D;EACF;EAEQ2B,WAAWA,CAAA,EAAS;IAC1B,IAAI,IAAI,CAAC9B,YAAY,EAAE;MACrB,IAAI,CAAC0D,oBAAoB,CAAC,YAAY,EAAE,IAAI,CAAC1D,YAAY,CAAC;;MAE1D;MACA,IAAI,IAAI,CAACS,QAAQ,CAACQ,WAAW,EAAE;QAC7B,IAAI,IAAI,CAACR,QAAQ,CAACS,SAAS,KAAK,CAAC,CAAC,IAAI,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACV,QAAQ,CAACS,SAAS,EAAE;UACrF,IAAI,CAACC,gBAAgB,EAAE;UACvB,IAAI,IAAI,CAACpB,YAAY,EAAE;YACrB,IAAI,CAACA,YAAY,CAACI,WAAW,GAAG,CAAC;YACjC,IAAI,CAACJ,YAAY,CAAC0D,IAAI,CAAC,CAAC,CAACa,KAAK,CAACmD,OAAO,CAACxE,KAAK,CAAC;UAC/C;UACA;QACF;MACF;IACF;IAEA,IAAI,CAAChD,SAAS,GAAG,KAAK;IACtB,IAAI,CAACE,WAAW,GAAG,CAAC;IACpB,IAAI,CAACgB,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACuC,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;EAChE;EAEQ8B,WAAWA,CAAA,EAAS;IAAA,IAAA4F,kBAAA,EAAAC,qBAAA;IAC1B,MAAMC,YAAY,GAAG,EAAAF,kBAAA,OAAI,CAAC5H,YAAY,cAAA4H,kBAAA,wBAAAC,qBAAA,GAAjBD,kBAAA,CAAmB1E,KAAK,cAAA2E,qBAAA,uBAAxBA,qBAAA,CAA0BrD,OAAO,KAAI,qBAAqB;IAC/E,IAAI,CAACb,oBAAoB,CAAC,SAAS,EAAEmE,YAAY,CAAC;IAClD,IAAI,CAAC5H,SAAS,GAAG,KAAK;IACtB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;EAChE;EAEQ+B,UAAUA,CAAA,EAAS;IACzB,IAAI,CAAC/B,SAAS,GAAG,IAAI;IACrB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;EAChE;EAEQgC,WAAWA,CAAA,EAAS;IAC1B,IAAI,CAAChC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACyD,oBAAoB,CAAC,mBAAmB,EAAE,IAAI,CAACzD,SAAS,CAAC;EAChE;EAEQyD,oBAAoBA,CAACiD,KAAgC,EAAE,GAAGmB,IAAW,EAAQ;IACnF,MAAMlB,QAAQ,GAAG,IAAI,CAACvG,cAAc,CAACsG,KAAK,CAAC;IAC3C,IAAIC,QAAQ,EAAE;MACZ,IAAI;QACDA,QAAQ,CAAc,GAAGkB,IAAI,CAAC;MACjC,CAAC,CAAC,OAAO7E,KAAK,EAAE;QACdwE,OAAO,CAACxE,KAAK,CAAC,YAAY0D,KAAK,YAAY,EAAE1D,KAAK,CAAC;MACrD;IACF;EACF;;EAEA;EACO8E,OAAOA,CAAA,EAAS;IACrB,IAAI,IAAI,CAACvH,YAAY,EAAE;MACrBqF,aAAa,CAAC,IAAI,CAACrF,YAAY,CAAC;MAChC,IAAI,CAACA,YAAY,GAAG,IAAI;IAC1B;IAEA,IAAI,IAAI,CAACT,YAAY,EAAE;MACrB,IAAI,CAACA,YAAY,CAACoE,KAAK,CAAC,CAAC;MACzB,IAAI,CAACpE,YAAY,CAACmE,MAAM,CAAC,CAAC;MAC1B,IAAI,CAACnE,YAAY,GAAG,IAAI;IAC1B;IAEA,IAAI,CAACO,aAAa,CAAC0H,KAAK,CAAC,CAAC;IAC1B,IAAI,CAAC3H,cAAc,GAAG,CAAC,CAAC;EAC1B;AACF;;AAEA;AACA,MAAM4H,sBAAsB,GAAG,IAAIpI,sBAAsB,CAAC,CAAC;AAC3D,eAAeoI,sBAAsB;AACrC,SAASpI,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}