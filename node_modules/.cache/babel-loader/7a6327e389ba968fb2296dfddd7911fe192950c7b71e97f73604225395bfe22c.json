{"ast":null,"code":"// import { audioController } from './audioController';\n// import { StreamingTrack } from '../types/track';\n\nclass OBSIntegration {\n  constructor() {\n    this.ws = null;\n    this.connection = {\n      isConnected: false,\n      version: '',\n      sceneName: '',\n      isStreaming: false,\n      isRecording: false\n    };\n    this.config = {\n      host: 'localhost',\n      port: 4455,\n      password: '',\n      autoConnect: false,\n      reconnectInterval: 5000\n    };\n    this.reconnectTimer = null;\n    this.messageId = 0;\n    this.pendingRequests = new Map();\n    // Event System\n    this.listeners = new Map();\n  }\n  // Configuration\n  setConfig(config) {\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    if (this.config.autoConnect && !this.connection.isConnected) {\n      this.connect();\n    }\n  }\n  getConfig() {\n    return {\n      ...this.config\n    };\n  }\n\n  // Connection Management\n  async connect() {\n    try {\n      const url = `ws://${this.config.host}:${this.config.port}`;\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        console.log('OBS WebSocket connected');\n        this.connection.isConnected = true;\n        this.authenticate();\n        this.getOBSInfo();\n      };\n      this.ws.onmessage = event => {\n        this.handleMessage(JSON.parse(event.data));\n      };\n      this.ws.onclose = () => {\n        console.log('OBS WebSocket disconnected');\n        this.connection.isConnected = false;\n        this.scheduleReconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('OBS WebSocket error:', error);\n        this.connection.isConnected = false;\n      };\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to OBS:', error);\n      return false;\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.connection.isConnected = false;\n  }\n  scheduleReconnect() {\n    if (this.config.autoConnect && this.reconnectTimer === null) {\n      this.reconnectTimer = setTimeout(() => {\n        this.connect();\n        this.reconnectTimer = null;\n      }, this.config.reconnectInterval);\n    }\n  }\n\n  // Authentication\n  async authenticate() {\n    if (!this.config.password) return;\n    try {\n      const response = await this.sendCommand('GetAuthRequired');\n      if (response.authRequired) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const auth = await this.sendCommand('Authenticate', {\n          auth: response.salt,\n          challenge: response.challenge\n        });\n        console.log('OBS authenticated successfully');\n      }\n    } catch (error) {\n      console.error('OBS authentication failed:', error);\n    }\n  }\n\n  // Command System\n  async sendCommand(command, params) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('OBS WebSocket not connected');\n    }\n    const id = ++this.messageId;\n    const message = {\n      requestType: command,\n      requestId: id,\n      ...(params && {\n        requestData: params\n      })\n    };\n    return new Promise((resolve, reject) => {\n      this.pendingRequests.set(id, {\n        resolve,\n        reject\n      });\n      this.ws.send(JSON.stringify(message));\n\n      // Timeout after 10 seconds\n      setTimeout(() => {\n        if (this.pendingRequests.has(id)) {\n          this.pendingRequests.delete(id);\n          reject(new Error(`OBS command timeout: ${command}`));\n        }\n      }, 10000);\n    });\n  }\n  handleMessage(data) {\n    if (data.requestId && this.pendingRequests.has(data.requestId)) {\n      const {\n        resolve,\n        reject\n      } = this.pendingRequests.get(data.requestId);\n      this.pendingRequests.delete(data.requestId);\n      if (data.error) {\n        reject(new Error(data.error));\n      } else {\n        resolve(data.responseData || data);\n      }\n    } else if (data.updateType) {\n      this.handleUpdate(data);\n    }\n  }\n  handleUpdate(data) {\n    switch (data.updateType) {\n      case 'SceneTransitionStarted':\n        this.connection.sceneName = data.sceneName;\n        this.emit('sceneChanged', data.sceneName);\n        break;\n      case 'StreamStarting':\n        this.connection.isStreaming = true;\n        this.emit('streamStarted');\n        break;\n      case 'StreamStopped':\n        this.connection.isStreaming = false;\n        this.emit('streamStopped');\n        break;\n      case 'RecordingStarting':\n        this.connection.isRecording = true;\n        this.emit('recordingStarted');\n        break;\n      case 'RecordingStopped':\n        this.connection.isRecording = false;\n        this.emit('recordingStopped');\n        break;\n    }\n  }\n\n  // OBS Information\n  async getOBSInfo() {\n    try {\n      const info = await this.sendCommand('GetVersion');\n      this.connection.version = info.obsVersion;\n      const scene = await this.sendCommand('GetCurrentProgramScene');\n      this.connection.sceneName = scene.currentProgramSceneName;\n      const streamStatus = await this.sendCommand('GetStreamStatus');\n      this.connection.isStreaming = streamStatus.outputActive;\n      const recordStatus = await this.sendCommand('GetRecordStatus');\n      this.connection.isRecording = recordStatus.outputActive;\n    } catch (error) {\n      console.error('Failed to get OBS info:', error);\n    }\n  }\n\n  // Scene Management\n  async getScenes() {\n    try {\n      const response = await this.sendCommand('GetSceneList');\n      return response.scenes.map(scene => scene.sceneName);\n    } catch (error) {\n      console.error('Failed to get scenes:', error);\n      return [];\n    }\n  }\n  async switchScene(sceneName) {\n    try {\n      await this.sendCommand('SetCurrentProgramScene', {\n        sceneName\n      });\n      this.connection.sceneName = sceneName;\n    } catch (error) {\n      console.error('Failed to switch scene:', error);\n      throw error;\n    }\n  }\n\n  // Source Management\n  async getSources() {\n    try {\n      const response = await this.sendCommand('GetSceneList');\n      return response.scenes.flatMap(scene => scene.sources.map(source => ({\n        ...source,\n        sceneName: scene.sceneName\n      })));\n    } catch (error) {\n      console.error('Failed to get sources:', error);\n      return [];\n    }\n  }\n  async toggleSource(sourceName, sceneName) {\n    try {\n      const scene = sceneName || this.connection.sceneName;\n      await this.sendCommand('ToggleSourceVisibility', {\n        sourceName,\n        sceneName: scene\n      });\n    } catch (error) {\n      console.error('Failed to toggle source:', error);\n      throw error;\n    }\n  }\n\n  // Audio Integration\n  async setSourceVolume(sourceName, volume) {\n    try {\n      await this.sendCommand('SetInputVolume', {\n        inputName: sourceName,\n        inputVolumeMul: volume\n      });\n    } catch (error) {\n      console.error('Failed to set source volume:', error);\n      throw error;\n    }\n  }\n  async getSourceVolume(sourceName) {\n    try {\n      const response = await this.sendCommand('GetInputVolume', {\n        inputName: sourceName\n      });\n      return response.inputVolumeMul;\n    } catch (error) {\n      console.error('Failed to get source volume:', error);\n      return 1.0;\n    }\n  }\n\n  // Streamlabs Integration\n  async triggerStreamlabsAlert(alertType, message) {\n    try {\n      // This would integrate with Streamlabs API\n      // For now, we'll create a custom source in OBS\n      await this.sendCommand('TriggerSourceFilter', {\n        sourceName: 'Streamlabs Alerts',\n        filterName: alertType,\n        filterSettings: {\n          message\n        }\n      });\n    } catch (error) {\n      console.error('Failed to trigger Streamlabs alert:', error);\n    }\n  }\n\n  // Browser Source Integration\n  async createBrowserSource(name, url, width = 1920, height = 1080) {\n    try {\n      await this.sendCommand('CreateInput', {\n        sceneName: this.connection.sceneName,\n        inputName: name,\n        inputKind: 'browser_source',\n        inputSettings: {\n          url,\n          width,\n          height\n        }\n      });\n    } catch (error) {\n      console.error('Failed to create browser source:', error);\n      throw error;\n    }\n  }\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event).push(callback);\n  }\n  off(event, callback) {\n    if (this.listeners.has(event)) {\n      const callbacks = this.listeners.get(event);\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n  emit(event, ...args) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => callback(...args));\n    }\n  }\n\n  // Getters\n  getConnection() {\n    return {\n      ...this.connection\n    };\n  }\n  isConnected() {\n    return this.connection.isConnected;\n  }\n\n  // Cleanup\n  destroy() {\n    this.disconnect();\n    this.listeners.clear();\n  }\n}\n\n// Export singleton instance\nexport const obsIntegration = new OBSIntegration();","map":{"version":3,"names":["OBSIntegration","constructor","ws","connection","isConnected","version","sceneName","isStreaming","isRecording","config","host","port","password","autoConnect","reconnectInterval","reconnectTimer","messageId","pendingRequests","Map","listeners","setConfig","connect","getConfig","url","WebSocket","onopen","console","log","authenticate","getOBSInfo","onmessage","event","handleMessage","JSON","parse","data","onclose","scheduleReconnect","onerror","error","disconnect","close","clearTimeout","setTimeout","response","sendCommand","authRequired","auth","salt","challenge","command","params","readyState","OPEN","Error","id","message","requestType","requestId","requestData","Promise","resolve","reject","set","send","stringify","has","delete","get","responseData","updateType","handleUpdate","emit","info","obsVersion","scene","currentProgramSceneName","streamStatus","outputActive","recordStatus","getScenes","scenes","map","switchScene","getSources","flatMap","sources","source","toggleSource","sourceName","setSourceVolume","volume","inputName","inputVolumeMul","getSourceVolume","triggerStreamlabsAlert","alertType","filterName","filterSettings","createBrowserSource","name","width","height","inputKind","inputSettings","on","callback","push","off","callbacks","index","indexOf","splice","args","forEach","getConnection","destroy","clear","obsIntegration"],"sources":["/Users/allendunn/Documents/Stream/stream-soundboard/src/services/obsIntegration.ts"],"sourcesContent":["// import { audioController } from './audioController';\n// import { StreamingTrack } from '../types/track';\n\nexport interface OBSConnection {\n  isConnected: boolean;\n  version: string;\n  sceneName: string;\n  isStreaming: boolean;\n  isRecording: boolean;\n}\n\nexport interface OBSCommand {\n  command: string;\n  params?: any;\n  response?: any;\n}\n\nexport interface OBSPluginConfig {\n  host: string;\n  port: number;\n  password?: string;\n  autoConnect: boolean;\n  reconnectInterval: number;\n}\n\nclass OBSIntegration {\n  private ws: WebSocket | null = null;\n  private connection: OBSConnection = {\n    isConnected: false,\n    version: '',\n    sceneName: '',\n    isStreaming: false,\n    isRecording: false\n  };\n  private config: OBSPluginConfig = {\n    host: 'localhost',\n    port: 4455,\n    password: '',\n    autoConnect: false,\n    reconnectInterval: 5000\n  };\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private messageId = 0;\n  private pendingRequests = new Map<number, { resolve: Function; reject: Function }>();\n\n  // Configuration\n  setConfig(config: Partial<OBSPluginConfig>): void {\n    this.config = { ...this.config, ...config };\n    if (this.config.autoConnect && !this.connection.isConnected) {\n      this.connect();\n    }\n  }\n\n  getConfig(): OBSPluginConfig {\n    return { ...this.config };\n  }\n\n  // Connection Management\n  async connect(): Promise<boolean> {\n    try {\n      const url = `ws://${this.config.host}:${this.config.port}`;\n      this.ws = new WebSocket(url);\n\n      this.ws.onopen = () => {\n        console.log('OBS WebSocket connected');\n        this.connection.isConnected = true;\n        this.authenticate();\n        this.getOBSInfo();\n      };\n\n      this.ws.onmessage = (event) => {\n        this.handleMessage(JSON.parse(event.data));\n      };\n\n      this.ws.onclose = () => {\n        console.log('OBS WebSocket disconnected');\n        this.connection.isConnected = false;\n        this.scheduleReconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('OBS WebSocket error:', error);\n        this.connection.isConnected = false;\n      };\n\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to OBS:', error);\n      return false;\n    }\n  }\n\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.connection.isConnected = false;\n  }\n\n  private scheduleReconnect(): void {\n    if (this.config.autoConnect && this.reconnectTimer === null) {\n      this.reconnectTimer = setTimeout(() => {\n        this.connect();\n        this.reconnectTimer = null;\n      }, this.config.reconnectInterval);\n    }\n  }\n\n  // Authentication\n  private async authenticate(): Promise<void> {\n    if (!this.config.password) return;\n\n    try {\n      const response = await this.sendCommand('GetAuthRequired');\n      if (response.authRequired) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const auth = await this.sendCommand('Authenticate', {\n          auth: response.salt,\n          challenge: response.challenge\n        });\n        console.log('OBS authenticated successfully');\n      }\n    } catch (error) {\n      console.error('OBS authentication failed:', error);\n    }\n  }\n\n  // Command System\n  private async sendCommand(command: string, params?: any): Promise<any> {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('OBS WebSocket not connected');\n    }\n\n    const id = ++this.messageId;\n    const message = {\n      requestType: command,\n      requestId: id,\n      ...(params && { requestData: params })\n    };\n\n    return new Promise((resolve, reject) => {\n      this.pendingRequests.set(id, { resolve, reject });\n      this.ws!.send(JSON.stringify(message));\n      \n      // Timeout after 10 seconds\n      setTimeout(() => {\n        if (this.pendingRequests.has(id)) {\n          this.pendingRequests.delete(id);\n          reject(new Error(`OBS command timeout: ${command}`));\n        }\n      }, 10000);\n    });\n  }\n\n  private handleMessage(data: any): void {\n    if (data.requestId && this.pendingRequests.has(data.requestId)) {\n      const { resolve, reject } = this.pendingRequests.get(data.requestId)!;\n      this.pendingRequests.delete(data.requestId);\n\n      if (data.error) {\n        reject(new Error(data.error));\n      } else {\n        resolve(data.responseData || data);\n      }\n    } else if (data.updateType) {\n      this.handleUpdate(data);\n    }\n  }\n\n  private handleUpdate(data: any): void {\n    switch (data.updateType) {\n      case 'SceneTransitionStarted':\n        this.connection.sceneName = data.sceneName;\n        this.emit('sceneChanged', data.sceneName);\n        break;\n      case 'StreamStarting':\n        this.connection.isStreaming = true;\n        this.emit('streamStarted');\n        break;\n      case 'StreamStopped':\n        this.connection.isStreaming = false;\n        this.emit('streamStopped');\n        break;\n      case 'RecordingStarting':\n        this.connection.isRecording = true;\n        this.emit('recordingStarted');\n        break;\n      case 'RecordingStopped':\n        this.connection.isRecording = false;\n        this.emit('recordingStopped');\n        break;\n    }\n  }\n\n  // OBS Information\n  private async getOBSInfo(): Promise<void> {\n    try {\n      const info = await this.sendCommand('GetVersion');\n      this.connection.version = info.obsVersion;\n      \n      const scene = await this.sendCommand('GetCurrentProgramScene');\n      this.connection.sceneName = scene.currentProgramSceneName;\n      \n      const streamStatus = await this.sendCommand('GetStreamStatus');\n      this.connection.isStreaming = streamStatus.outputActive;\n      \n      const recordStatus = await this.sendCommand('GetRecordStatus');\n      this.connection.isRecording = recordStatus.outputActive;\n    } catch (error) {\n      console.error('Failed to get OBS info:', error);\n    }\n  }\n\n  // Scene Management\n  async getScenes(): Promise<string[]> {\n    try {\n      const response = await this.sendCommand('GetSceneList');\n      return response.scenes.map((scene: any) => scene.sceneName);\n    } catch (error) {\n      console.error('Failed to get scenes:', error);\n      return [];\n    }\n  }\n\n  async switchScene(sceneName: string): Promise<void> {\n    try {\n      await this.sendCommand('SetCurrentProgramScene', { sceneName });\n      this.connection.sceneName = sceneName;\n    } catch (error) {\n      console.error('Failed to switch scene:', error);\n      throw error;\n    }\n  }\n\n  // Source Management\n  async getSources(): Promise<any[]> {\n    try {\n      const response = await this.sendCommand('GetSceneList');\n      return response.scenes.flatMap((scene: any) => \n        scene.sources.map((source: any) => ({\n          ...source,\n          sceneName: scene.sceneName\n        }))\n      );\n    } catch (error) {\n      console.error('Failed to get sources:', error);\n      return [];\n    }\n  }\n\n  async toggleSource(sourceName: string, sceneName?: string): Promise<void> {\n    try {\n      const scene = sceneName || this.connection.sceneName;\n      await this.sendCommand('ToggleSourceVisibility', { sourceName, sceneName: scene });\n    } catch (error) {\n      console.error('Failed to toggle source:', error);\n      throw error;\n    }\n  }\n\n  // Audio Integration\n  async setSourceVolume(sourceName: string, volume: number): Promise<void> {\n    try {\n      await this.sendCommand('SetInputVolume', { \n        inputName: sourceName, \n        inputVolumeMul: volume \n      });\n    } catch (error) {\n      console.error('Failed to set source volume:', error);\n      throw error;\n    }\n  }\n\n  async getSourceVolume(sourceName: string): Promise<number> {\n    try {\n      const response = await this.sendCommand('GetInputVolume', { inputName: sourceName });\n      return response.inputVolumeMul;\n    } catch (error) {\n      console.error('Failed to get source volume:', error);\n      return 1.0;\n    }\n  }\n\n  // Streamlabs Integration\n  async triggerStreamlabsAlert(alertType: string, message: string): Promise<void> {\n    try {\n      // This would integrate with Streamlabs API\n      // For now, we'll create a custom source in OBS\n      await this.sendCommand('TriggerSourceFilter', {\n        sourceName: 'Streamlabs Alerts',\n        filterName: alertType,\n        filterSettings: { message }\n      });\n    } catch (error) {\n      console.error('Failed to trigger Streamlabs alert:', error);\n    }\n  }\n\n  // Browser Source Integration\n  async createBrowserSource(name: string, url: string, width: number = 1920, height: number = 1080): Promise<void> {\n    try {\n      await this.sendCommand('CreateInput', {\n        sceneName: this.connection.sceneName,\n        inputName: name,\n        inputKind: 'browser_source',\n        inputSettings: {\n          url,\n          width,\n          height\n        }\n      });\n    } catch (error) {\n      console.error('Failed to create browser source:', error);\n      throw error;\n    }\n  }\n\n  // Event System\n  private listeners: Map<string, Function[]> = new Map();\n\n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event)!.push(callback);\n  }\n\n  off(event: string, callback: Function): void {\n    if (this.listeners.has(event)) {\n      const callbacks = this.listeners.get(event)!;\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n\n  private emit(event: string, ...args: any[]): void {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event)!.forEach(callback => callback(...args));\n    }\n  }\n\n  // Getters\n  getConnection(): OBSConnection {\n    return { ...this.connection };\n  }\n\n  isConnected(): boolean {\n    return this.connection.isConnected;\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.disconnect();\n    this.listeners.clear();\n  }\n}\n\n// Export singleton instance\nexport const obsIntegration = new OBSIntegration();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}