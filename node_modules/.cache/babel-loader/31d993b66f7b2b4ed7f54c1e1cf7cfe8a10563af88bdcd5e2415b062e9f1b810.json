{"ast":null,"code":"class WebhookService {\n  constructor() {\n    this.handlers = new Map();\n    this.pendingTracks = new Map();\n    this.webhookUrl = void 0;\n    this.webhookUrl = process.env.REACT_APP_WEBHOOK_URL || 'https://webhook.site/your-unique-url';\n    this.initializeWebhook();\n  }\n  initializeWebhook() {\n    console.log('🔗 Webhook service initialized with URL:', this.webhookUrl);\n\n    // Don't automatically simulate events - wait for handlers to be registered\n    console.log('🔗 Webhook service ready - will simulate events when handlers are registered');\n  }\n  registerHandler(taskId, handler) {\n    this.handlers.set(taskId, handler);\n    this.pendingTracks.set(taskId, {\n      status: 'generating',\n      startTime: Date.now()\n    });\n\n    // Notify that generation has started\n    handler.onTrackGenerating(taskId);\n    console.log(`🔗 Registered webhook handler for task: ${taskId}`);\n\n    // If this is the first handler, start simulating webhook events\n    if (this.handlers.size === 1) {\n      console.log('🔗 First handler registered, starting webhook simulation...');\n      this.simulateWebhookEvents();\n    }\n  }\n  unregisterHandler(taskId) {\n    this.handlers.delete(taskId);\n    this.pendingTracks.delete(taskId);\n    console.log(`🔗 Unregistered webhook handler for task: ${taskId}`);\n  }\n  processWebhookEvent(event) {\n    const handler = this.handlers.get(event.taskId);\n    if (!handler) {\n      // Only log warning for non-test events to reduce noise\n      if (!event.taskId.startsWith('test_task_')) {\n        console.warn(`🔗 No handler found for webhook event: ${event.taskId}`);\n      }\n      return;\n    }\n    switch (event.status) {\n      case 'completed':\n        if (event.audioUrl) {\n          var _event$metadata, _event$metadata2, _event$metadata3, _event$metadata4, _event$metadata5;\n          const track = {\n            id: `suno_${event.taskId}`,\n            title: ((_event$metadata = event.metadata) === null || _event$metadata === void 0 ? void 0 : _event$metadata.title) || `AI Generated Track ${event.taskId}`,\n            artist: 'AI-generated track via Suno API',\n            duration: ((_event$metadata2 = event.metadata) === null || _event$metadata2 === void 0 ? void 0 : _event$metadata2.duration) || 150,\n            audioUrl: event.audioUrl,\n            category: 'gaming',\n            // Default category\n            subcategory: 'ambient',\n            // Default subcategory\n            mood: ((_event$metadata3 = event.metadata) === null || _event$metadata3 === void 0 ? void 0 : _event$metadata3.mood) || 'chill',\n            energy: 3,\n            // Default medium energy\n            tags: ['ai-generated', 'custom', ((_event$metadata4 = event.metadata) === null || _event$metadata4 === void 0 ? void 0 : _event$metadata4.genre) || 'electronic'],\n            streamSafe: true,\n            loopFriendly: true,\n            hasIntro: false,\n            hasOutro: false,\n            uploadDate: new Date().toISOString(),\n            uploadedBy: 'system',\n            approved: true,\n            // Legacy fields for backward compatibility\n            sunoId: event.taskId,\n            streamingCategory: 'chill_gaming',\n            energyLevel: 'medium',\n            genre: ((_event$metadata5 = event.metadata) === null || _event$metadata5 === void 0 ? void 0 : _event$metadata5.genre) || 'electronic',\n            dmcaSafe: true,\n            vodSafe: true,\n            license: 'royalty_free',\n            licenseDetails: 'Suno AI generated track',\n            platformCompliance: {\n              twitch: 'safe',\n              youtube: 'safe',\n              facebook: 'safe',\n              tiktok: 'safe'\n            },\n            usageTracking: {\n              usageCount: 0,\n              lastUsed: undefined\n            },\n            agencyNotes: 'AI-generated track via webhook'\n          };\n          handler.onTrackCompleted(event.taskId, track);\n          this.pendingTracks.delete(event.taskId);\n          this.handlers.delete(event.taskId);\n          console.log(`🎵 Track completed: ${event.taskId}`, track);\n        }\n        break;\n      case 'failed':\n        handler.onTrackFailed(event.taskId, event.error || 'Unknown error');\n        this.pendingTracks.delete(event.taskId);\n        this.handlers.delete(event.taskId);\n        console.error(`❌ Track generation failed: ${event.taskId}`, event.error);\n        break;\n      case 'generating':\n        handler.onTrackGenerating(event.taskId);\n        console.log(`🔄 Track still generating: ${event.taskId}`);\n        break;\n    }\n  }\n  getPendingTracks() {\n    return new Map(this.pendingTracks);\n  }\n  isTrackGenerating(taskId) {\n    return this.pendingTracks.has(taskId);\n  }\n  getGenerationTime(taskId) {\n    const track = this.pendingTracks.get(taskId);\n    if (track) {\n      return Date.now() - track.startTime;\n    }\n    return null;\n  }\n\n  // Manually trigger webhook simulation for testing\n  triggerTestWebhooks() {\n    if (this.handlers.size === 0) {\n      console.log('🔗 No handlers registered, creating test handlers first...');\n\n      // Create test handlers for demonstration\n      const testHandler = {\n        onTrackGenerating: taskId => console.log(`🔄 Test track generating: ${taskId}`),\n        onTrackCompleted: (taskId, track) => {\n          console.log(`✅ Test track completed: ${taskId}`, track);\n          // Save to storage for demonstration\n          const trackStorageService = require('./trackStorageService').default;\n          trackStorageService.saveTrack(track);\n        },\n        onTrackFailed: (taskId, error) => console.error(`❌ Test track failed: ${taskId}`, error)\n      };\n      this.registerHandler('test_task_1', testHandler);\n      this.registerHandler('test_task_2', testHandler);\n    } else {\n      console.log('🔗 Triggering test webhooks for existing handlers...');\n      this.simulateWebhookEvents();\n    }\n  }\n  simulateWebhookEvents() {\n    // Only simulate events if there are registered handlers\n    if (this.handlers.size === 0) {\n      console.log('🔗 No webhook handlers registered, skipping test events');\n      return;\n    }\n\n    // Simulate a track completing after 5 seconds\n    setTimeout(() => {\n      // Only process if we still have handlers\n      if (this.handlers.size > 0) {\n        const testEvent = {\n          taskId: 'test_task_1',\n          status: 'completed',\n          audioUrl: 'https://api.sunoapi.org/sample1.mp3',\n          metadata: {\n            title: 'Test AI Track',\n            duration: 180,\n            genre: 'ambient',\n            mood: 'chill'\n          }\n        };\n        this.processWebhookEvent(testEvent);\n      }\n    }, 5000);\n\n    // Simulate another track completing after 8 seconds\n    setTimeout(() => {\n      // Only process if we still have handlers\n      if (this.handlers.size > 0) {\n        const testEvent2 = {\n          taskId: 'test_task_2',\n          status: 'completed',\n          audioUrl: 'https://api.sunoapi.org/sample2.mp3',\n          metadata: {\n            title: 'Test Energetic Track',\n            duration: 195,\n            genre: 'electronic',\n            mood: 'energetic'\n          }\n        };\n        this.processWebhookEvent(testEvent2);\n      }\n    }, 8000);\n  }\n  destroy() {\n    this.handlers.clear();\n    this.pendingTracks.clear();\n    console.log('🔗 Webhook service destroyed');\n  }\n}\nconst webhookService = new WebhookService();\nexport default webhookService;","map":{"version":3,"names":["WebhookService","constructor","handlers","Map","pendingTracks","webhookUrl","process","env","REACT_APP_WEBHOOK_URL","initializeWebhook","console","log","registerHandler","taskId","handler","set","status","startTime","Date","now","onTrackGenerating","size","simulateWebhookEvents","unregisterHandler","delete","processWebhookEvent","event","get","startsWith","warn","audioUrl","_event$metadata","_event$metadata2","_event$metadata3","_event$metadata4","_event$metadata5","track","id","title","metadata","artist","duration","category","subcategory","mood","energy","tags","genre","streamSafe","loopFriendly","hasIntro","hasOutro","uploadDate","toISOString","uploadedBy","approved","sunoId","streamingCategory","energyLevel","dmcaSafe","vodSafe","license","licenseDetails","platformCompliance","twitch","youtube","facebook","tiktok","usageTracking","usageCount","lastUsed","undefined","agencyNotes","onTrackCompleted","onTrackFailed","error","getPendingTracks","isTrackGenerating","has","getGenerationTime","triggerTestWebhooks","testHandler","trackStorageService","require","default","saveTrack","setTimeout","testEvent","testEvent2","destroy","clear","webhookService"],"sources":["/Users/allendunn/Documents/Stream/stream-soundboard/src/services/webhookService.ts"],"sourcesContent":["import { StreamingTrack } from '../types/track';\n\nexport interface SunoWebhookEvent {\n  taskId: string;\n  status: 'generating' | 'completed' | 'failed';\n  audioUrl?: string;\n  error?: string;\n  metadata?: {\n    title?: string;\n    duration?: number;\n    genre?: string;\n    mood?: string;\n  };\n}\n\nexport interface WebhookHandler {\n  onTrackGenerating: (taskId: string) => void;\n  onTrackCompleted: (taskId: string, track: StreamingTrack) => void;\n  onTrackFailed: (taskId: string, error: string) => void;\n}\n\nclass WebhookService {\n  private handlers: Map<string, WebhookHandler> = new Map();\n  private pendingTracks: Map<string, { status: 'generating'; startTime: number }> = new Map();\n  private webhookUrl: string;\n\n  constructor() {\n    this.webhookUrl = process.env.REACT_APP_WEBHOOK_URL || 'https://webhook.site/your-unique-url';\n    this.initializeWebhook();\n  }\n\n  private initializeWebhook() {\n    console.log('🔗 Webhook service initialized with URL:', this.webhookUrl);\n    \n    // Don't automatically simulate events - wait for handlers to be registered\n    console.log('🔗 Webhook service ready - will simulate events when handlers are registered');\n  }\n\n  public registerHandler(taskId: string, handler: WebhookHandler): void {\n    this.handlers.set(taskId, handler);\n    this.pendingTracks.set(taskId, { status: 'generating', startTime: Date.now() });\n    \n    // Notify that generation has started\n    handler.onTrackGenerating(taskId);\n    \n    console.log(`🔗 Registered webhook handler for task: ${taskId}`);\n    \n    // If this is the first handler, start simulating webhook events\n    if (this.handlers.size === 1) {\n      console.log('🔗 First handler registered, starting webhook simulation...');\n      this.simulateWebhookEvents();\n    }\n  }\n\n  public unregisterHandler(taskId: string): void {\n    this.handlers.delete(taskId);\n    this.pendingTracks.delete(taskId);\n    console.log(`🔗 Unregistered webhook handler for task: ${taskId}`);\n  }\n\n  public processWebhookEvent(event: SunoWebhookEvent): void {\n    const handler = this.handlers.get(event.taskId);\n    if (!handler) {\n      // Only log warning for non-test events to reduce noise\n      if (!event.taskId.startsWith('test_task_')) {\n        console.warn(`🔗 No handler found for webhook event: ${event.taskId}`);\n      }\n      return;\n    }\n\n    switch (event.status) {\n      case 'completed':\n        if (event.audioUrl) {\n          const track: StreamingTrack = {\n            id: `suno_${event.taskId}`,\n            title: event.metadata?.title || `AI Generated Track ${event.taskId}`,\n            artist: 'AI-generated track via Suno API',\n            duration: event.metadata?.duration || 150,\n            audioUrl: event.audioUrl,\n            category: 'gaming', // Default category\n            subcategory: 'ambient', // Default subcategory\n            mood: (event.metadata?.mood as any) || 'chill',\n            energy: 3, // Default medium energy\n            tags: ['ai-generated', 'custom', event.metadata?.genre || 'electronic'],\n            streamSafe: true,\n            loopFriendly: true,\n            hasIntro: false,\n            hasOutro: false,\n            uploadDate: new Date().toISOString(),\n            uploadedBy: 'system',\n            approved: true,\n            // Legacy fields for backward compatibility\n            sunoId: event.taskId,\n            streamingCategory: 'chill_gaming',\n            energyLevel: 'medium',\n            genre: (event.metadata?.genre as any) || 'electronic',\n            dmcaSafe: true,\n            vodSafe: true,\n            license: 'royalty_free',\n            licenseDetails: 'Suno AI generated track',\n            platformCompliance: {\n              twitch: 'safe',\n              youtube: 'safe',\n              facebook: 'safe',\n              tiktok: 'safe'\n            },\n            usageTracking: {\n              usageCount: 0,\n              lastUsed: undefined\n            },\n            agencyNotes: 'AI-generated track via webhook'\n          };\n\n          handler.onTrackCompleted(event.taskId, track);\n          this.pendingTracks.delete(event.taskId);\n          this.handlers.delete(event.taskId);\n          \n          console.log(`🎵 Track completed: ${event.taskId}`, track);\n        }\n        break;\n\n      case 'failed':\n        handler.onTrackFailed(event.taskId, event.error || 'Unknown error');\n        this.pendingTracks.delete(event.taskId);\n        this.handlers.delete(event.taskId);\n        \n        console.error(`❌ Track generation failed: ${event.taskId}`, event.error);\n        break;\n\n      case 'generating':\n        handler.onTrackGenerating(event.taskId);\n        console.log(`🔄 Track still generating: ${event.taskId}`);\n        break;\n    }\n  }\n\n  public getPendingTracks(): Map<string, { status: 'generating'; startTime: number }> {\n    return new Map(this.pendingTracks);\n  }\n\n  public isTrackGenerating(taskId: string): boolean {\n    return this.pendingTracks.has(taskId);\n  }\n\n  public getGenerationTime(taskId: string): number | null {\n    const track = this.pendingTracks.get(taskId);\n    if (track) {\n      return Date.now() - track.startTime;\n    }\n    return null;\n  }\n\n  // Manually trigger webhook simulation for testing\n  public triggerTestWebhooks(): void {\n    if (this.handlers.size === 0) {\n      console.log('🔗 No handlers registered, creating test handlers first...');\n      \n      // Create test handlers for demonstration\n      const testHandler: WebhookHandler = {\n        onTrackGenerating: (taskId) => console.log(`🔄 Test track generating: ${taskId}`),\n        onTrackCompleted: (taskId, track) => {\n          console.log(`✅ Test track completed: ${taskId}`, track);\n          // Save to storage for demonstration\n          const trackStorageService = require('./trackStorageService').default;\n          trackStorageService.saveTrack(track);\n        },\n        onTrackFailed: (taskId, error) => console.error(`❌ Test track failed: ${taskId}`, error)\n      };\n      \n      this.registerHandler('test_task_1', testHandler);\n      this.registerHandler('test_task_2', testHandler);\n    } else {\n      console.log('🔗 Triggering test webhooks for existing handlers...');\n      this.simulateWebhookEvents();\n    }\n  }\n\n  private simulateWebhookEvents(): void {\n    // Only simulate events if there are registered handlers\n    if (this.handlers.size === 0) {\n      console.log('🔗 No webhook handlers registered, skipping test events');\n      return;\n    }\n\n    // Simulate a track completing after 5 seconds\n    setTimeout(() => {\n      // Only process if we still have handlers\n      if (this.handlers.size > 0) {\n        const testEvent: SunoWebhookEvent = {\n          taskId: 'test_task_1',\n          status: 'completed',\n          audioUrl: 'https://api.sunoapi.org/sample1.mp3',\n          metadata: {\n            title: 'Test AI Track',\n            duration: 180,\n            genre: 'ambient',\n            mood: 'chill'\n        }\n        };\n        this.processWebhookEvent(testEvent);\n      }\n    }, 5000);\n\n    // Simulate another track completing after 8 seconds\n    setTimeout(() => {\n      // Only process if we still have handlers\n      if (this.handlers.size > 0) {\n        const testEvent2: SunoWebhookEvent = {\n          taskId: 'test_task_2',\n          status: 'completed',\n          audioUrl: 'https://api.sunoapi.org/sample2.mp3',\n          metadata: {\n            title: 'Test Energetic Track',\n            duration: 195,\n            genre: 'electronic',\n            mood: 'energetic'\n          }\n        };\n        this.processWebhookEvent(testEvent2);\n      }\n    }, 8000);\n  }\n\n  public destroy(): void {\n    this.handlers.clear();\n    this.pendingTracks.clear();\n    console.log('🔗 Webhook service destroyed');\n  }\n}\n\nconst webhookService = new WebhookService();\nexport default webhookService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}